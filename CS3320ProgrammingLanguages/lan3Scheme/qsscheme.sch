
(define ar (vector 11 22 44 33 77 66 55 99))
(define size (vector-length ar))

(define ar2 (vector 112 28 81 198 92 466 58 597 46 989))
(define size2 (vector-length ar2))

(define ar3 (vector 222 444 587 456 455 678 716 729 782 239 195 495 794 309 988))
(define size3 (vector-length ar3))

(define partition
  (lambda (low high)
    ;(display "partition\n")
    (let ((pivot (vector-ref ar high)) (i (- low 1)) (j low))
      ;(display "start of loop: ")
      ;(display i)
      ;(display " ")
      ;(display j)
      ;(display "\n")
      (while (< j high)
        ;(display "loop\n")
        (if (< (vector-ref ar j) pivot)
          (begin
            ;(display "element is smaller\n")
            (set! i (+ i 1))
            ;(display "i is incremented: ")
            ;(display i)
            ;(display "\n")
            (let ((temp 0))   ;swap ar[i+1] with ar[high]
                ;(display "temp is ")
                ;(display temp)
                ;(display "\n")
              (set! temp (vector-ref ar i))
                ;(display "temp is now ")
                ;(display temp)
                ;(display "\n")
              (vector-set! ar i (vector-ref ar j))
              (vector-set! ar j temp)
              ;(display "swap done\n")
            )   ;end of swap
            ;(display ar)
          )
        )
        ;(display j)
        ;(display "\n")
        (set! j (+ j 1))
      )
      ;(display "\tout\n")
      (let ((temp 0))   ;swap ar[i+1] with ar[high]
          ;(display "temp is ")
          ;(display temp)
          ;(display "\n")
        (set! temp (vector-ref ar (+ i 1)))
          ;(display "temp is now ")
          ;(display temp)
          ;(display "\n")
        (vector-set! ar (+ i 1) (vector-ref ar high))
          ;(display "check\n")
        (vector-set! ar high temp)
        ;(display "swap done\n")
      )   ;end of swap
      ;(display ar)
      (+ i 1)
    )
    ;(display "partition ")
    ;(+ 1 1)
  )
)

(define quicksort
  (lambda (low high)
    ;(display low)
    ;(display " ")
    ;(display high)
    ;(display "\n")
    (cond ((not (integer? low)) (display "low is not a valid index\n"))
      ((not (integer? high)) (display "high is not a valid index\n"))
	    ((not (and (> low -1) (> high -1))) (display "error one of these: low or high < 0\n"))
      ((< low high)
		    (let ((pi (partition low high)))
          (quicksort low (- pi 1))
          (quicksort (+ pi 1) high)
          ;(display "good ")
          ;(display pi)
          ;(display "\n")
        )
        ;(display "part\n")
      );all good
      ;(else
      ;  (display " done\n")
      ;)
    )
    ;(display ar)
    ;(display "\n")
    (vector-copy ar)
  )
)
(define main
  (lambda ()
    (display "unsorted:\n")
    (display ar)  ;global var instead of pass by reference
    (display "\nsorted:\n")
    (display (quicksort 0 (- size 1) ))
    (display "\n\nunsorted:\n")
    (set! ar ar2)
    (set! size size2)
    (display ar)
    (display "\nsorted:\n")
    (display (quicksort 0 (- size 1) ))
    (display "\n\nunsorted:\n")
    (set! ar ar3)
    (set! size size3)
    (display ar)
    (display "\nsorted:\n")
    (display (quicksort 0 (- size 1) ))
    (display "\n\nunsorted:\n")

  )
)

(main)
